cd /Users/ted.hsu/Desktop/Projects/allianz-onesub-www

# Check if jq is installed
if ! command -v jq &> /dev/null; then
    echo "jq is not installed. Installing jq..."
    brew install jq
fi

# Remove File if it already exists
csv_file="./cve_data.csv"

if [ -f "$csv_file" ] ; then
    rm "$csv_file"
fi

# Define the API URL
API_URL="https://services.nvd.nist.gov/rest/json/cves/2.0"
# API key
API_KEY="4e5e4372-7e5b-4a89-a28b-4e046ef9db3b"

dependencies=$(jq -r '.dependencies' package-lock.json)

# Maximum retry attempts
MAX_RETRIES=100

# Total number of entries to process
TOTAL_ENTRIES=$(jq -r '.dependencies | length' package-lock.json)
CURRENT_INDEX=0

# Run jq command to extract keys and versions from package-lock.json
jq -r '.dependencies | to_entries[] | "\(.key) \(.value.version)"' package-lock.json | while read -r line; do
    # Increment current index
    CURRENT_INDEX=$((CURRENT_INDEX + 1))
    
    # Specify the keyword search parameter
    KEYWORD=$(echo "$line" | awk '{print $1}')
    VERSION=$(echo "$line" | awk '{print $2}')
    # For testing
    # KEYWORD="crypto-js"
    # VERSION="4.0.0"
    # KEYWORD="xml2js"
    # VERSION="0.4.23"

    # echo "Fetching data from NVD NIST API for keyword: '${KEYWORD}'..."
    echo "Fetching data from NVD NIST API (${CURRENT_INDEX}/${TOTAL_ENTRIES}): ${KEYWORD} ${VERSION}..."

    retry=0
    while [ ${retry} -lt ${MAX_RETRIES} ]; do
        # Construct the full API request URL
        # REQUEST_URL="${API_URL}?keywordSearch=${KEYWORD}&keywordExactMatch"
        REQUEST_URL="${API_URL}?virtualMatchString=cpe:2.3:*:*:${KEYWORD}:${VERSION}:*:*:*"

        # Send a GET request using curl with progress information and API key in header,
        # and save the response to a temporary file
        temp_file=$(mktemp)
        http_code=$(curl -s -o "$temp_file" -w "%{http_code}" -# --header "apiKey: ${API_KEY}" "$REQUEST_URL")
        # http_code=$(curl -s -o "$temp_file" -w "%{http_code}" -# --header "apiKey: ${API_KEY}" "https://services.nvd.nist.gov/rest/json/cves/2.0?virtualMatchString=cpe:2.3:*:*:xml2js&versionStart=0.4.23&versionStartType=including&versionEnd=0.4.23&versionEndType=including")
        # http_code=$(curl -s -o "$temp_file" -w "%{http_code}" -# --header "apiKey: ${API_KEY}" "https://services.nvd.nist.gov/rest/json/cves/2.0?virtualMatchString=cpe:2.3:*:*:xml2js:0.4.23:*:*:*")

        # Check if curl encountered a  error
        if [ "$http_code" -eq 503 ]; then
            echo "Received HTTP 503 error. Retrying (attempt ${retry}/${MAX_RETRIES})..."
            rm "$temp_file"
            retry=$((retry + 1))
            sleep 6  # Adjust sleep time as needed
        else
            break  # Exit the retry loop if request was successful
        fi
    done

    # Check if maximum retries exceeded
    if [ ${retry} -eq ${MAX_RETRIES} ]; then
        echo "Maximum retry attempts (${MAX_RETRIES}) reached. Exiting..."
        exit 1
    fi

    # Extract totalResults from JSON
    total_results=$(jq -r '.totalResults' "$temp_file")

    # Check if totalResults is 0, skip processing if true
    if [ -z "$total_results" ] || [ "$total_results" -eq 0 ]; then
        # echo "No vulnerabilities found for '${KEYWORD}'."
        # Extract fields from JSON using jq and format as CSV
        package_name=$KEYWORD
        package_version=$VERSION
        cve_format=$(jq -r '.format' "$temp_file")
        cve_version=$(jq -r '.version' "$temp_file")
        query_date=$(jq -r '.timestamp' "$temp_file")

        echo "Package Name,$package_name" >> "$csv_file"
        echo "Package Version,$package_version" >> "$csv_file"
        echo "CVE Format,$cve_format" >> "$csv_file"
        echo "CVE Version,$cve_version" >> "$csv_file"
        echo "Query Date,$query_date" >> "$csv_file"
        echo "CVE ID,Published Date,Last Modified Date,CVSS Base Score,CVSS Base Severity,Description" >> "$csv_file"
        echo "No vulnerabilities found for '${KEYWORD}'." >> "$csv_file"

        # Remove temporary file
        rm "$temp_file"
    else
        # Extract fields from JSON using jq and format as CSV
        package_name=$(jq -r '.vulnerabilities[0].cve.configurations[0].nodes[0].cpeMatch[0].criteria' "$temp_file" | cut -d':' -f5)
        package_version=$VERSION
        # package_version=$(jq -r '.vulnerabilities[0].cve.configurations[0].nodes[0].cpeMatch[0].criteria' "$temp_file" | cut -d':' -f6)
        cve_format=$(jq -r '.format' "$temp_file")
        cve_version=$(jq -r '.version' "$temp_file")
        query_date=$(jq -r '.timestamp' "$temp_file")

        # Testing
        # if [ "$package_name" != "$KEYWORD" ]; then
        #     echo "No vulnerabilities found for keyword '${KEYWORD}'. Skipping..."
        # else
            # Create CSV file with header and extracted data (only for the first iteration)
            # if [ ! -f "$csv_file" ]; then
                echo "Package Name,$package_name" >> "$csv_file"
                echo "Package Version,$package_version" >> "$csv_file"
                echo "CVE Format,$cve_format" >> "$csv_file"
                echo "CVE Version,$cve_version" >> "$csv_file"
                echo "Query Date,$query_date" >> "$csv_file"
                echo "CVE ID,Published Date,Last Modified Date,CVSS Base Score,CVSS Base Severity,Description" >> "$csv_file"
            # fi

            # Loop through each vulnerability and append to CSV file
            jq -r '.vulnerabilities[] | 
                [
                    .cve.id,
                    .cve.published,
                    .cve.lastModified,
                    .cve.metrics.cvssMetricV31[0].cvssData.baseScore,
                    .cve.metrics.cvssMetricV31[0].cvssData.baseSeverity,
                    .cve.descriptions[0].value
                ] | @csv' "$temp_file" >> "$csv_file"

            # Remove temporary file
            rm "$temp_file"


        # fi
    fi
    # Display success message for the current keyword
    # echo "Fetching data for keyword '${KEYWORD}' completed."
    sleep 6
done

# Inform user about the CSV file location
echo "CSV file saved: $csv_file"
